"""
xks -- the xenakis sieve, reimplementation

  don't over-think. but if you do, think of ECS.
"""

import copy
import functools
import operator


def parse_residual_string(s):
    """
    parses a residual and returns a tuple (modulus, shift, neg) representing it.
    """

    raise NotImplementedError


def parse_group_string(s):
    """
    parses a group and returns a Group object representing it.
    """

    raise NotImplementedError


def parse_sieve_string(s):
    """
    parses a sieve string and returns a set of objects representing it.
    """

    raise NotImplementedError


def as_operable(o):
    """
    converts o into the appropriate Operable type.
    """

    if isinstance(o, str):
        raise NotImplementedError("haven't implemented yet")

    if isinstance(o, int):
        raise NotImplementedError("haven't implemented yet")

    if isinstance(o, (list, set, tuple)):
        raise NotImplementedError("haven't implemented yet")

    if isinstance(o, SieveResult):
        raise NotImplementedError("haven't implemented yet")

    return o


def operable_argument(func):
    """
    converts the operands of a PDM arithmetic function to the appropriate type for performing logical
    operations.
    """

    @functools.wraps(func)
    def wrapped(*args, **kwargs):
        """
        wrapper function that performs the conversion, if needed.
        """

        args = tuple(map(as_operable, args))
        return func(*args, **kwargs)

    return wrapped


def is_member(n, res, transpose=0):
    if isinstance(res, Group):
        if res.op_string == "&":
            outcome = True
        else:
            outcome = False

        for partial in res.partials:
            outcome = res.operator_(outcome, is_member(n, partial, transpose=transpose))
        return outcome

    if res.modulus in {0, 1}:
        if res.modulus == 0:
            outcome = False
        else:
            outcome = True

        if res.neg:
            outcome = not outcome

        return outcome

    m = res.modulus
    s = res.shift + transpose
    neg = res.neg

    outcome = (n - s) % m == 0

    if neg:
        outcome = not outcome

    return outcome


class SieveResult:
    """
    the outcome of a calculation on a sieve. it maintains the broadcasting functions of
    the underlying data, as well as conversions, display capabilities, and reverse-processing--the
    ability to create sieves from results. this entails that a sieve result can be created by passing
    a set or list to the constructor.

    an intermediary, or instantiation point for sets and sequences.
    """

    z = None  # iterable of values the sieve result was checked against
    s = None  # iterable of values that exist in the sieve
    sieve = None  # the sieve that generated the result (if generated by a sieve)

    def as_sieve(self):
        raise NotImplementedError

    def unit(self):
        raise NotImplementedError

    def set(self):
        raise NotImplementedError

    def delta(self):
        raise NotImplementedError

    def binary(self):
        raise NotImplementedError


class Unary:
    """
    if a class can be negated (NOT) then it implements this interface.
    """

    neg = False


class Period:
    """
    if a class can have a period then it implements this interface.
    """

    def period(self):
        raise NotImplementedError


class Logical:
    """
    if a class can be operated on with AND, OR, and NOT, then it implements this interface.
    """

    neg = False
    transpose = 0

    @operable_argument
    def __and__(self, other):
        """
        AND (&) for intersection.
        """

        if isinstance(self, Group) and self.operator_ is operator.and_:
            copy_ = copy.copy(self)
            copy_.partials += [other]

            return copy_

        return Group(self, other, operator_=operator.and_)

    @operable_argument
    def __or__(self, other):
        """
        OR (|) for union.
        """

        if isinstance(self, Group) and self.operator_ is operator.or_:
            copy_ = copy.copy(self)
            copy_.partials += [other]

            return copy_

        return Group(self, other, operator_=operator.or_)

    def __neg__(self):
        copy_ = copy.copy(self)
        copy_.neg = not copy_.neg

        return copy_


class Operable(Unary, Period, Logical):
    def period(self):
        """
        calculate the period (LCM) of an operable object.
        """

        raise NotImplementedError

    def __call__(self, z, transpose=0):
        """
        calculate a sieve result for the given input range z.
        """

        raise NotImplementedError


class Residual(Operable):
    """
    these are individual mod structures. a modulus and shift are given, as well as the unary property--
    which defaults to False.

    can be used to test, as well as perform comparative and logical operations with other sieves and
    arithmetic.

    a full sieve is composed of residuals combined using logic operators.
    """

    def __call__(self, z, transpose=0):
        transpose = transpose if transpose else self.transpose
        return [n for n in z if is_member(n, self, transpose)]

    def __init__(self, m, shift=0, neg=False):
        if isinstance(m, str):
            m, shift, neg = parse_residual_string(m)

        self.modulus, self.shift, self.neg = m, shift, neg

    def __str__(self):
        return ("-" if self.neg else "") + f"{self.modulus}@{self.shift}"

    def __repr__(self):
        return f"Residual({self.modulus}, {self.shift}, {self.neg})"

    def period(self):
        raise NotImplementedError


class Sieve(Operable):
    """
    the encapsulation class of a residual, or one or more intersection or union groups. has various
    additional methods for formatting, testing, and interacting with other Xenakis Structures.
    """

    def __call__(self, z, transpose=0):
        raise NotImplementedError

    def __init__(self, *args, transpose=0):
        partials = list(map(as_operable, args))

        if not len(partials):
            partials = {Residual(0)}  # default to the empty set Sieve

        self.partials = partials

    def __str__(self):
        return ' '.join(map(str, self.partials))

    def __repr__(self):
        return ("-" if self.neg else "") + 'Sieve(' + ', '.join(
            list(map(repr, self.partials))) + f", transpose={self.transpose})"

    def period(self):
        raise NotImplementedError


class Group(Operable):
    """
    a group of residuals related by logical operators.
    """

    partials = list()

    def __init__(self, *args, operator_=operator.and_):
        if isinstance(operator_, str):
            operator_ = operator.and_ if operator_ == "&" else "|"

        self.partials = list(map(as_operable, args))
        self.operator_ = operator_

    def __call__(self, z, transpose=0):
        transpose = transpose if transpose else self.transpose
        return [n for n in z if is_member(n, self, transpose)]

    def __str__(self):
        return "{" + f" {self.op_string} ".join(map(str, self.partials)) + "}"

    def __repr__(self):
        return ("-" if self.neg else "") + "Group(" + ", ".join(
            map(repr, self.partials)) + f", operator_='{self.op_string}')"

    def period(self):
        raise NotImplementedError

    @property
    def op_string(self):
        """
        the operator character
        """

        return '&' if self.operator_ is operator.and_ else '|'


sieve = Sieve(Residual(3, 4) & Residual(6, 19) | Residual(69, 2) & Residual(38, 9))
sieve.transpose = 3

print(sieve, sieve.partials[0](range(100)))
